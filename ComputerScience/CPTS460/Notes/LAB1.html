<html><head><title>460 Week 1 Notes</title></head><body bgcolor="#00cccc" text="#000000">

<h1>460 Lab Assignment #1</h1>

<pre>                   CS460 Lab Assignment #1 
###########################################################################
               DUE : Week of Jan. 19, 2009
               DEMO: Sign up for demo SAME week
###########################################################################
   
1. REQURIEMENT:
   To deveop a boot program for booting the MTX operating system.

2. Background Reading List and Timetable:
   Notes #2: Booting
   LAB1-PRE work : DUE         : Week of Jan. 12, 2009
   LAB1          : DUE and DEMO: Week of Jan. 19, 2009 

3. PRE-LAB1 WORK: TO BE COMPLETED IN WEEK OF JAN. 12, 2009 !!!!

3-1. Download the MTX image file
         http://www.eecs.wsu.edu/~cs460/samples/LAB1/mtximage
     dump it to a floppy disk by
         dd if=mtximage  of=/dev/fd0 
     Then, boot up MTX from the floppy disk.
     Test run the MTX operating system as demonstrated in class.

                         CONTENTS of the MTX disk image:

     |  B0  | B1 ...................................................... B1339 |
     --------------------------------------------------------------------------
     |booter|   An EXT2 file system for MTX; kernel=/boot/mtx                 |  
     --------------------------------------------------------------------------
   
     LAB#1 IS FOR YOU TO WRITE A BOOTER PROGRAM TO REPLACE THE booter IN BLOCK#0 
     TO BOOT UP THE MTX KERNEL, which is the image file /boot/mtx.
   
3-2. Download and install the BCC package to YOUR Linux system:
         http://www.eecs.wsu.edu/~cs460/samples/BCC/
     Read the HOWTO file for install instructions.

3-3. Background: Computer Architecture and Programming Environment
     Lab#1 assumes the following hardware and software environments.

     Hardware: Intel X86 based PC running Linux. If you don't have such a PC,
               try to get one or work on the LAB PCs in Sloan 327.
     Sofware:  BCC compiler-assembler-linker under Linux. 

     When a PC starts, it is in the so-called UNPROTECTED mode, also known as 
     the 16-bit mode. In such a mode, the PC's CPU can only execute 16-bit code 
     and access 1 MB of memory. The diagram below shows the 1MB memory layout, 
     shown in 64KB segments.

               0x0000    0x1000   .......     0x9000     0xA000 ... 0xF000
               -----------------------------------------------------------
               |         |     ..........     |          |          BIOS |
               -----------------------------------------------------------
               |&lt;-------------- 640KB RAM area ---------&gt;|&lt;--- ROM -----&gt;|

     The CPU's internal registers are
              segment registers: CS, DS, SS, ES 
              general registers: AX, BX, CX, DX, BP, SI, DI
              status  register : FLAG
              stack pointer    : SP
              instruction point or program counter: IP
     All registers are 16-bit wide. 
  
     The CPU operates as follows:
     First, at any given time, the CPU can only access FOUR segments of memory, 
     each segment is 64KB in size and pointed by a segment register:

                CS -&gt; Code  segment  = program code or instructions
                DS -&gt; Data  segment  = static and global data (ONE COPY only)
                SS -&gt; Stack segment  = stack area for calling and local variables. 
                ES -&gt; Extra segment  = temp area; may be used for malloc()/mfree()
 
    Second, the CPU's executes in an infinite loop:

             while (power on){
                 (1). IP points at the instruction in Code segment of memory;
                 (2). Fetch instruction (always from Code segment), so the
                      20-bit physical address is (CS&lt;&lt;4 + IP);
                 (3). Decode the instruction = (opcode, operands);
                 (4). If operands are in memory: load operands into CPU 
                      (always from Data segment), so the 20-bit physical
                      address is (DS&lt;&lt;4 + operandAddress)
                 (5). Execute the instruction, which may change IP (by 
                      br, jmp, call, ret) OR SP (by push,pop,call,ret).
                      When SP is used, e.g. in push, pop, call, ret, it's
                      always in the Stack sgement, so the 20-bit physical
                      address is (SS&lt;&lt;4 + SP). 
                      If result must go back to memory, it's again in the
                      Data segment.
                 (6). Checking for interrupts OR execution error. If so,
                      start exception processing.
              }

     Third, the number of DISTINCT segments presented to the CPU depends on the
     memory model of the executing program, which in turn is determined by the
     compiler and linker used to generate the binary executable image. The most
     often used memory models are

           SMALL  model (COM files): CS=DS=SS all in ONE segment &lt;= 64KB
           MEDIUM model (EXE files): CS=CodeSegment, DS=SS=Data+Stack segment
                                       (up to 128 KB of execution image size)
 
    SMALL memory model programs are easier to maintain, for example, they can
    be loaded to any segment in memory and setup to run correctly with ease.
    They are typically used in a simple environment such as during booting.

    Finally, in order to run a SMALL memory model program, the following steps
    are needed:
        (1). A C compiler and assembler that generate 16-bit (object) code
        (2). A linker that combines the object code to generate a ONE-segment
             binary executable image. 
             We shall use BCC under Linux to do (1) and (2).
        (3). LOAD the binary executable image into memory (at a segment 
             boundary, of course) and set CPU's CS=DS=SS = loaded segment.
             Set SP at the HIGH end of the segment.
             Set IP at the beginning instruction in the segment.
        Then the CPU will execute the image correctly.
 
3-4. An assembly file bs.s in in the ~cs360/samples/LAB1/ directory.  
     You may download and use it directly. 

! bs.s file 
!============================================================================
     .globl begtext, begdata, begbss                      ! needed by linker
     .text                                                ! these tell as:
      begtext:                                            ! text,data,bss segments
     .data                                                ! are all the same.
      begdata:
     .bss
      begbss:
     .text
!============================================================================

       BOOTSEG =  0x9000        ! Boot block is loaded again to here.
       SSP      =   8192        ! Stack pointer at SS+8KB
	
       .globl _main,_prints                                 ! IMPORT symbols
       .globl _getc,_putc,_diskr,_setes,_inces,_error       ! EXPORT symbols
                                                
        !-------------------------------------------------------
        ! Only one SECTOR loaded at (0000,7C00). Get entire BLOCK in
        !-------------------------------------------------------
        mov  ax,#BOOTSEG    ! set ES to 0x9000
        mov  es,ax
        xor  bx,bx          ! clear BX = 0
        !---------------------------------------------------
        !  diskio[0,0] to read boot BLOCK to [0x9000,0]     
        !---------------------------------------------------
        xor  dx,dx          ! drive 0, head 0
        xor  cx,cx
        incb cl             ! cyl 0, sector 1
        mov  ax, #0x0202    ! READ 1 block
        int  0x13

        jmpi    start,BOOTSEG           ! CS=BOOTSEG, IP=start

start:                    
        mov     ax,cs                   ! establish segments again
        mov     ds,ax                   ! we know ES,CS=0x8F00. Let DS=CS  
        mov     ss,ax                   ! SS = CS ===&gt; all point at 0x8F00
        mov     es,ax
        mov     sp,#SSP                 ! SP = 8KB above 0x90000

        mov     ax,#0x0012              ! 640x480 color     
	int     0x10 
	
        call _main                      ! call main() in C
     
        test ax, ax
	jne  _error 

        jmpi 0,0x1000
 

!======================== I/O functions =================================
        !---------------------------------------------
        !  char getc()   function: returns a char
        !---------------------------------------------
_getc:
        xorb   ah,ah           ! clear ah
        int    0x16            ! call BIOS to get a char in AX
        ret 

        !----------------------------------------------
        ! void putc(char c)  function: print a char
        !----------------------------------------------
_putc:           
        push   bp
	mov    bp,sp
	
        movb   al,4[bp]        ! get the char into aL
        movb   ah,#14          ! aH = 14
        movb   bl,#0x0D        ! bL = cyan color 
        int    0x10            ! call BIOS to display the char

        pop    bp
	ret




       !---------------------------------------
       ! diskr(cyl, head, sector, buf)
       !        4     6     8      10
       !---------------------------------------
_diskr:                             
        push  bp
	mov   bp,sp            ! bp = stack frame pointer

        movb  dl, #0x00        ! drive 0=FD0
        movb  dh, 6[bp]        ! head
        movb  cl, 8[bp]        ! sector
        incb  cl
        movb  ch, 4[bp]        ! cyl
        mov   bx, 10[bp]       ! BX=buf ==&gt; memory addr=(ES,BX)
        mov   ax, #0x0202      ! READ 2 sectors to (EX, BX)

        int  0x13              ! call BIOS to read the block 
        jb   _error            ! to error if CarryBit is on [read failed]

        pop  bp                
	ret
	
	
! void set_es(unsigned short segment)  set ES register to segment
_setes:  
         push  bp
         mov   bp,sp
         mov   ax,4[bp]        
         mov   es,ax
         pop   bp
	 ret
	   
! void inces() inc ES by 0x40, or 1KB
_inces:                         
         mov   ax,es
         add   ax,#0x40
         mov   es,ax
         ret

        !------------------------------
        !       error &amp; reboot
        !------------------------------
_error:
        mov  bx, #bad
        push bx
        call _prints
        
        int  0x19                       ! reboot

bad:    .asciz  "Error!"

! end of bs.s file


     BCC's C compiler prefix every GLOBAL symbol with an underscore, so that
     main  becomes _main, getc becomes _getc, etc.
     BCC's assembler uses the same convention for global symbols, which must be
     declared by the .globl statements in assembly code. 

     As shown, bs.s EXPORTs the following functions
        char getc();
        void putc(char c);

 
        void diskr(int cyl, int head, int sector, char *buf)
        viod setes(int segment);
        void inces();

     which are callable from C. 
    
     ***********   THE LOGIC OF bs.s IS AS FOLLOWS:   *************

     (1). It is to be combined with a .c source file to form a booter code 
          which occupies the boot BLOCK (block#0) of a floppy disk.

     (2). During booting, BIOS loads 512 bytes of this boot BLOCK to
          (0x0000,0x7C00) and jumps to it. Although only half in, it can start
          execution because it does not need any portion that's not yet loaded.

     (3). It sets ES=0x9000, BX=0 and calls diskr() to load the entire boot
          BLOCK to 0x9000.

     (4). Then it jumps to the symbol start relative to 0x9000, and 
          continues to execute from there. This jump sets CS to 0x9000. 

     (5). It sets DS,SS to CS, and SP to 8KB above SS. Note that ES is already 
          set to 0x9000 in (3). Thus, CS,DS,SS and ES all point at the same 
          segment address 0x9000.

     (6). It then calls YOUR  main() in C, which is specified in 3 below.

     (7). Upon return from C code, bs.s checks the return value, which
          should be 0 if no error.
          If no error, it jumps to (0x1000, 0) to start up MTX.
          else; it displays an Error! message and reboot.

3. YOUR C code:

     First, some notes about using BCC's C compiler:

       (1). Use identifier names &lt;= 8 chars; the compiler will truncate long names
            to 8 chars, including the leading _ 
       (2). Declare all variables BEFORE using them (else compile error)!!!!
       (3). Declare function parameters OUTSIDE the function heading, e.g.
                         int myfun(x, y) int x; char *y;
                         {
                         }

            instead of   int myfun(int x, char *y)
                         {
                         }
            
            (You may use the bcc -ansi option to allow ANSI style C statements)

       (4). Whenever in doubt, use pretheses to ensure correct precedence, e.g.
               a = b % 2 + 1;  should be written as a = (b % 2) + 1; if that's
                               what you meant.

       Other than these, bcc is very good as it produces excellent erro diagnostics. 
 
       Second, never assume that your program will work. More likely than not, it 
       will NOT work at all or not work correctly. An easy way to TRACE your program 
       execution, especially for debugging, is to use putc('1'); putc('2'), etc. in 
       your C code. This way you can easily see where the program stopped working.
 
     You must implement the main(), gets() and prints(char *s) functions in C. 
     You may use the C library functions strcmp(), strcpy(), strlen(), etc. 
     as long as they do NOT need the support of an operating system. But you may 
     NOT use printf(), scanf(), putchar(), getchar(), ... because these I/O 
     functions depend on the support of an operating system. During booting, 
     there is NO operating system yet!

     For PRE-LAB1 work, write YOUR main() function to do the following:

          (1). Print a string "What's your name?".
          (2). Read in a name string, e.g. "John Smith".
          (3). Print a string "Welcome, John Smith!".
          (4). If the name string == NULL, print "bye bye!" and return 0
               else, loop back to (1) again.
 
    LAB#1 IS FOR YOU TO MODIFY THIS SIMPLE main() FUNCTION TO ACTUALLY BOOT 
    UP THE MTX OPERATING SYSTEM. 

4. HOW TO cross COMPILE and LINK under Linux: (Use these as a sh script)
     --------------------------------------------------------------
     echo comiling ......
     bcc  -c main.c
     as86 -o bs.o  bs.s
     echo linking .......
     asld -d bs.o  main.o  /usr/lib/bcc/libc.a
     echo check a.out size
     ls -l a.out
     echo dumping a.out to floppy .......
     dd if=a.out  of=/dev/fd0  bs=1024 count=1
     -------------------------------------------------------------
     The last step dumps (at most 1KB of) a.out to BLOCK 0 of /dev/fd0.
     The resulting disk should be bootable.
 
                           IMPORTANT:
     ****************************************************************
     Your a.out must be &lt;= 1024 bytes in order for it to fit into ONE 
     disk block.

     THERE IS NO FAT IN MY  bs.s  CODE. The .s type says loud and clear
     that it's already Slim!  If your a.out is too big, it has been eating 
     too much junk food.  You must put it on diet until it weighs no more 
     than 1024 pounds (bytes, that is).
     ****************************************************************

5.  Compile and link bs.s with YOUR main.c to generate a booter and dump it
    to BLOCK #0 of a floppy disk. Boot up from the floppy and make sure your
    program works correctly.

6.  How to write YOUR I/O functions:
    During booting, only BIOS is available for I/O. The getc()/putc() fucntions
    in bs.s calls BIOS to input a char from beyboard or output a char to display.

    Use getc() to implement YOUR OWN

        gets(s) char *s;  which inputs a string from the keyboard.

        NOTE: getc() of BIOS does not echo the input char. YOU must echo the input 
              chars to see what are being typed. While collecting inputs, char *s 
              MUST have memory space to hold the input chars. From the keyboard, 
              the ENTER key ('\r' in C) signifies the end of an input string. 
 
    Use putc(c) char c; to implement YOUR own 
        prints(s) char *s; 
    which prints a string to the display.
=============================================================================================


7. MAIN TASK OF LAB#1:  DUE and DEMO in Week of Jan. 19, 2009
   
7-1. Refer to the CONTENTS of the MTX disk image:

     |  B0  | B1 ............................ B1339 |
     ------------------------------------------------
     |booter|   An EXT2 file system for MTX         |  
     ------------------------------------------------   

     Block# 0 contains a booter, which can boot up MTX.
     The remaining parts of the disk is an EXT2 file system (per CS360) with
     1KB block size. The EXT2 file system contents are

                                    /
                                    |
                 -------------------------------------------
                 |         |        |        |       |      |
                bin       dev      etc      user    sys    boot
                 |         |        |        |              |
              commands  devFiles  passwd   userDirs        mtx 
                                                    (bootable MTX kernels)

     where /boot/mtx is a bootable MTX kernel. 

     Write YOUR main() as follows:

     (1). Prompt for filename to boot, e.g. mtx or image, etc. You may assume
          that all bootable files are in the /boot directory.
     (2). Find the file. Recall that "finding a file amounts to finding its 
          inode". 
     (3). From the file's inode, find the disk blocks of the file:
               i_block[0] to i_block[11] are DIRECT blocks, and
               i_blokc[12] points to INDIRECT blocks.
          MTX kerenl has at most 64 (1KB) blocks, so no double-indirect blocks.
 
     (4). Load the blocks of /boot/mtx into memory at the segment 0x1000.
     (5). return 0 to bs.s for OK, return non-zero for failure.
     ==========================================================================  
     (6). If YOUR main() loads the disk blocks of mtx successfully and returns 0, 
          bs.s will jump to (0x1000, 0) to start up MTX.

 
7-2. How to read a disk block into memory:

     The function diskr(cyl, head, sector, buf) in bs.s reads a disk block 
     (2 sectors) at (cyl, head, sector) into memory at the physical address 
     (ES&lt;&lt;4 + buf), i.e. buf is a VIRTUAL address in the segment pointed by ES. 
     For example,
 
          ES -&gt; Data segment, buf is the address of a global variable in C, then
                diskr(cyl, head, sector, buf); reads a block into buf;
          ES -&gt; 0x2000, buf=0, then diskr(cyl, head, sector, buf); reads a block
                               to (0x2000&lt;&lt;4 + 0), etc.

     The functions setes(segment);  sets ES to any segment,
                   inces();         increment ES by 0x40, which is 1KB.
  
     A 1.44MB floppy disk has 80 cylinders, 2 heads per cylinder and 18 sectors
     under each head. The PHYSICAL layout of a floppy disk is as follows, where
     cyl, head, sector all count from 0.

         ----------------------------------------------------------------------
         |s0 s1 .... s17 | s18  .... s35 | s36 .....   s53|s54         s71| ...
         ----------------------------------------------------------------------

         |&lt;-- head 0----&gt;|&lt;--- head 1 --&gt;|&lt;--- head 0 ---&gt;|&lt;-- head 1 ---&gt;| .... 
         |&lt;--------- ---cyl 0 ----------&gt;|&lt;--------   cyl 1 -------------&gt;| ....       

     A disk block consists of 2 contigious sectors. Given a block number, blk,
     which counts from 0 to 1339, how to convert blk into (cyl, head, sector)? 
     -------------------------------------------------------------------------
                  Use the Mailman's algorithm (per CS360) to
                 FIGURE OUT THE CONVERSION ALGORITHM YOURSELF
     -------------------------------------------------------------------------
     Then write a function
                  get_block(blk, buf) int blk; char buf[];
                  {
                      //convert blk to (cyl,head,sector);
                      diskr(cyl, head, sector, buf);
                  }
     which will load the disk block into memory at (ES, buf).
 
</pre></body></html>