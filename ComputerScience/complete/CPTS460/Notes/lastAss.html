<Title>460 Class Notes</Title>
<Body bgcolor="#00cccc" text="#000000">

<H1>460 Last LAB ASSIGNMENT</H1>

<Pre>
                     LAST LAB ASSIGNMENT
                   DUE and DEMO: CLOSE WEEK
      
0. Get MTX image files: Download files from ~samples/LAST/

       mtximage : MTX system image
         USER   : for generating binary executable command files.
          |  
    -------------------------------- 
    mku, type.h, u.s, ucode.c, mtxlib 
 
1. Syscalls in MTX Kernel

The following table lists the syscall numbers and functions of the MTX kernel.
The functions are (almost) identical to their counterparts in Unix. The entries
marked with * are exceptions as noted below.

  Number          Function 
  ---       --------------------------
   0         pid = getpid()
   1         ps()                          // ps in Kmode
   2         chname(char *newname)
   3         kmode()                       /* go Kmode */   
   4         switch()                      /* switch task */  

   5         pid = fork()                  /* fork an identical child task */ 
*  6         exec(char *cmdLine)           /* change image to filename */

  20         pid = wait(int *exitValue)    /* wait for child to die */ 
  21         mkdir(char *dirname)
  22         rmdir(char *dirname)
* 23         creat(char *filename)
  24         rm(char *filename)

  26         chdir(char *dirname)

* 28         fd = open(char *filename, int mode)  /* mode=0|1|2|3 OR UNIX's O_RDONLY,...*/
  29         close(int fd)
* 30         lseek(int fd, long offset)

  33         chmod(char *filename, 0xxx);
  34         chown(char *filename, int uid);
  35         n =  read(fd, buf, nbytes)
  36         n = write(fd, buf, nbytes)

  38         stat(char *filename, struct stat *s) 
  39         getcwd(char *s)            /* get cwd string */
  40         pipe(int pd[2])                    
  41         dup(fd)
  42         dup2(fd1, fd2)
  43         ps()                      // print proc status in Kmode
  44         uid=getuid();             // getuid
  45         setuid(int uid);          // set uid  
  46         gettty(char *tty);        // get /dev/ttyX string in PROC
  47         settty(char *tty);        // set PROC.tty string
  48         fstat(int fd, struct stat *s);   // stat a file descriptor

  50         kill(int signal#, int pid)           // deliver signal to pid
  51         signal(int signal#, void catcher())  // install catcher()

  52         sleep(int t)                   // pause for t seconds
  53         settimer(int t)                // set timer for t seconds

  90          sync()                        // flush I/O buffers to disk

  96          hits                          // buffer cache hit ratio

  99          exit(exitValue);              // enter kernel to die 
=============================================================================

                         EXCEPTIONS:

     exec(char *cmdLine):    Recall that in Unix if you enter a cmdLine
                                     a.out  arg1  arg2 ... argn
     it is used in execl() as
                                execl(a.out, a.out, arg1, arg2,...,argn, 0);
     OR as argc, argv[] in      execve(argc, argv);

     In our MTX, the entire cmdLine is used in the exec() call.
     For example, if you enter     cat /a/b/c/d     to sh (kcsh, that is), 
     the entire line  "cat /a/b/c/d"  is used in the exec() syscall.  
     Furthermore, the entire line is passed to the new image, which can be 
     written as

             !============= u.s file =======================
                    .globl _crt0, _exit

              auto_start:
              exprot auto_start
              
                        call   _crt0
            
                        push   #0
                        call   _exit


             //********** crt0.c file *******************
             crt0(cmdLine) char *cmdLine;    /* bcc style C */
             {
                 // parse cmdLine as argv[0], argv[1],...., argv[n]
                 //       int argc =  |<------ argc ------------|
                 main(argc, argv);
             }

             //************ cat.c file ******************
             main(argc, argv) int argc; char *argv[];
             {
                // argv[0] = "cat"; argv[1] = "/a/b/c/d"
             }


     As shown above, in crt0(), the original cmdLine = "cat /a/b/c/d" is parsed
     into argc and argv[]. Then it calls main(argc, argv) as in standard C.

     To help you get started, crt0.o is included in mtxlib. But you MUST write
     your own crt0.c to replace the ctr0.o in mtxlib. 

     -------------------------------------------------------------------- 
     creat(char *filename) :  default file permissions=0644
     --------------------------------------------------------
     fd = open(char *filename, int flag) : flag=0/1/2/3 for r/w/rw/append
                            OR #include "type.h" and then use UNIX's  
                               O_RDONLY, _O_WRONLY, O_RDWR,
                               O_WRONLY|O_CREAT, O_RDWR|O_CREAT|O_APPEND, etc
   
     ------------------------------------------------------------
     lseek(int fd, long offset) : always from beginning of opened file
     -------------------------------------------------------------

2. Operation of the MTX system:

   Download ~samples/SH/mtx.gz, dd it to a FF disk. The MTX image supports all 
   the syscalls listed above.

   When MTX starts, it mounts /dev/fd0 as the root file system. Thus, the 
   boot disk must be a valid EXT2 file system with the following contents:

                |----bin/ : All binary executables are in /bin
                |
                |---dev/ : special files tty0  c 4 0 
                |                        ttyS0 c 5 0 
                |                        ttyS1 c 5 1   
          /-----|                        lp0   c 6 0
                |---etc/ : passwd file 
                |           
                |---boot/: bootable MTX images
                |
                |---user/: users HOME directories
  
  After mounting the root file system, P0 creats P1, whose Umode image is 
  the /bin/init program. P1 goes to Umode directly to execute /bin/init, 
  in which it forks children P2 on /dev/tty0, P3 on /dev/ttyS0 and P4 on 
  /dev/ttyS1. Then P1 waits for any child proc to die.
  Henceforth, P1 plays the role of the INIT process (P1) in Unix.

                          Proc#2:
  (1). P2 is a login process. It executes /bin/login on the console
       /dev/tty0. So the special file /dev/tty0 MUST exist.
       To support serial terminals and printer, /dev/ttyS0, /dev/ttyS1 
       and /dev/lp0 must also exist.

  (2). In /bin/login, P2 opens its tty special file (/dev/tty0) as stdin,
       stdout and stderr. Then it displays (to its stdout)
                  login: 
       and waits for a user to login.  
  When a user tries to login, it reads the user name and password 
  (from its stdin), opens the /etc/passwd file to authenticate the user.  
  Each line of /etc/passwd has the format:

          username:password:gid:uid:fullname:HOMEDIR:program
  e.g.    root:xxxxxxx:1000:0:superuser:/root:sh

  (Use plain text for password OR devise your own encryption schemes)

  If the user has a valid account in /etc/passwd, P2 becomes his/her
  process. It chdir to the user's HOMEDIR and execute the listed program, 
  such as sh (/bin/sh).
 
  (3). then (in sh) it loops forever (until "logout" or Contro-D):
        {
           prompts for a command line, e.g. cmdLine="cat filename"
           if (cmd == "logout") 
              syscall to die;

           // if just ONE cmd:  
           pid = fork();
           if (pid==0)
               exec(cmdLine);
           else
               pid = wait(&status);
        }    

   (3). When the child proc terminates (by exit() syscall to MTX kernel), 
        it wakes up sh, which prompts for another cmdLine, etc.

   (4). When sh dies, it wakes up its parent, INIT, which forks another
        login process.         
==========================================================================

3. OBJECTIVES:
   The purpose of this assignment is for you to write YOUR OWN INIT, login, 
   sh and other user command programs. Among these, sh is the most important. 
   Accordingly, it will carry the most weight. A sample sh.c is shown here 
   to help you get started:
 
char cmdLine[64];

#include "ucode.c"       /* contains syscall functions */

int menu()
{
  printf("#############################################################\n");
  printf("#  ls       cd     pwd    cat   more    cp     mv   >   >>  #\n");
  printf("#  mkdir    rmdir  creat  rm    chmod   chown  lpr  <   |   #\n");
  printf("#############################################################\n");
}

main(argc, argv) int argc; char *argv[];
{
  int pid, me, status;

  me = getpid();
  printf("Enter ? for help menu\n");
  while(1){
     printf("input command : ");
     gets(cmdLine);
     if (cmdLine[0]==0)
         continue;

     token(cmdLine);   /* break up cmdLine into name[0], name[1],.... */

     if (strcmp(name[0], "?")==0 || strcmp(name[0], "help")==0){
        menu(); continue;
     }

     if (strcmp(name[0], "logout")==0)
         exit(0);

     /****************************************************************
        NOTE: some commands, e.g. cd, MUST be done by sh itself.
              OTHER commands will be done as shown below:
      ****************************************************************/
        
     /***** fork a child to execute the command ******/
     pid = fork();
     if (pid){
         printf("parent sh waits for child to die\n");
         pid = wait(&status);
     }
     else{
         printf("child task %d exec to %s\n", getpid(), name[0]);
            exec(cmdLine);
         printf("exec failed\n");
     }
  }
}

=============================================================================

As usual, you must compile sh.c and link it with u.o crt0.o to generate an 
executable a.out. NOTE that every a.out must have a header because my loader 
needs the file's header for sizes in order to allocate memory).

                  A sample u.s file is shown below.

|======================================================================
|                            u.s file
|======================================================================	

.globl begtext, begdata, begbss            | needed by linker

.globl _crt0, _syscall, _exit              | IMPORT EXPORT symbols

.text                                      | these tell as:	
begtext:                                   | text,data,bss segments
.data                                      | are all the same.
begdata:
.bss
begbss:
.text     

auto_start:                                | bcc's linker needs this for          
export auto_start                          | main(argc, argv)

        call _crt0

        push #0
        call _exit                          | call exit(0) to die
	
_syscall:
        int  80
        ret

|======================================================================

uio.o in mtxlib contains I/O functions such as printf(). You may use your 
own I/O functions during linking. If so, you must define getc() and putc() 
from User mode as follows:

         int getc()
         {
             int c;
             read(0, &c, 1);
             return (c & 0x7F);
         }

         int putc(c) int c;
         {
             write(1, &c, 1);
         }

NOTE that these are NO LONGER calls to BIOS, but read/write syscalls to 
the MTX kernel. It depends on the file descriptors 0 and 1 at this moment, 
which may NOT be /dev/tty0. This makes I/O redirection possible.
============================================================================

4. Command Programs:

   Each command (except >, <, >>, |) shown in the Menu is an executable
   file in the /bin directory. The programs are developed in exactly the 
   same way as that of sh.  For example, the mkdir program is shown below.

=====================  mkdir.c  file  ==============================
#include "ucode.c"

main(argc, argv) int argc; char *argv[];
{
    printf("$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n");
    printf("      This is KCW's mkdir in action          \n");
    printf("$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n");

    /* for the mkdir program, the original cmdLine = "mkdir dirname"
    if (argc < 2)
        /* show usage and exit(1) */
    }

    if ( mkdir(argv[1]) < 0)  /* which is  syscall(21, argv[1], 0, 0);  */ 
       printf("mkdir OK\n");
    else
       printf("mkdir failed\n");
}
==============================================================================

Similarly for other commands.


                      5. ASSIGNMENTS:
                     DUE in CLOSED week
                   ORAL EXAM during DEMO
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
5-1. Develop YOUR OWN programs for
             init                    // for process P1 
             login                   // for login processes
             cat   [filename]        // cat filename or stdin to stdout
             more  filename          // more as in Unix   
             grep  pattern filename  // print lines containing pattern 
            
5-2. Write YOUR OWN sh.c to support I/O redirections and pipes:

     Examples:  cat [filename] >  newfile 
                cat [filename] >> appendFile                           

     REQUIRED:  cat                  // TRY THIS UNDER Linux to see what does it do
                cat  > newfile       // TRY THIS under Linux !!!!
                cat >> newfile

                a.out < inFile   /* read inputs from inFile */

                cat filename | more
                cat filename | grep test
                cat filename | grep print | more
                cat filename | cat | grep print | more
 $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$


//*************************************************************************
//                      Logic of init.c 
// NOTE: this init.c creates only ONE login process on console=/dev/tty0
// YOUR init.c must also create login processes on serial ports /dev/ttyS0
// and /dev/ttyS1.. 
//************************************************************************

int pid, child, status;
int stdin, stdout;

#include "ucode.c"

main(argc, argv) int argc; char *argv[];
{
   // open /dev/tty0 for READ and WRTIE in order to display messages
   stdin  = open("/dev/tty0", O_RDONLY);
   stdout = open("/dev/tty0", O_WRONLY);

   // Now we can use printf, which calls putc(), which writes to fd=1
   printf("KCINIT : fork a login task on console\n"); 
   child = fork();

   if (child)
       parent();
   else  /* login task */
       login();
}      

int login()
{
    exec("longin /dev/tty0");
}
      
int parent()
{
  while(1){
    printf("KCINIT : waiting .....\n");

    pid = wait(&status);

    if (pid == child)
        fork another login child
    else
        printf("INIT : buried an orphan child %d\n", pid);

  }
}


//***********************************************************************
//                   LOGIC of login.c file
//***********************************************************************
#include "ucode.c"

char *tty;
int stdin, stdout, stderr;

main(argc, argv) int argc; char *argv[];   // invoked by exec("login /dev/ttyxx")
{
  tty =  argv[1];

  // close 0, 1 from parent INIT
  close(0); close(1);

  // open own tty as stdin, stdout, stderr
  stdin  = open(tty, O_RDONLY);
  stdout = open(tty, O_WRONLY);
  stderr = open(tty, O_WRONLY);

  settty(tty);   // store tty string in PROC.tty[] for putc()

  // NOW we can use printf, which calls putc() to our tty
  printf("KCLOGIN : open %s as stdin, stdout, stderr\n", tty);

  signal(2,1);  // syscall(51, 2, 1); ignore Control-C interrupts so that 
                // Control-C KILLs other procs on this tty but not the main sh

  while(1){
    1. show login:           to stdout
    2. read user nmae        from stdin
    3. show passwd:
    4. read user passwd

    5. verify user name and passwd from /etc/passwd file

    6. if (user account valid){
          setuid to user uid.
          chdir to user HOME directory.
          exec to the program in users's account
       }
       printf("login failed, try again\n");
  }
}
